#!/usr/bin/env ruby

require 'sinatra'
require 'haml'
require 'sequel'
require 'distro-package'
require 'package-updater'
require 'cgi'

db_path = './db.sqlite'
DB = Sequel.sqlite(db_path)

helpers do

  def maintainers
    unless @maintainers
      @maintainers = DB[:nix_maintainers].select(:maintainer).distinct.map(:maintainer).map{ |m| m.gsub(/<.*>/,"").strip }
    end
    @maintainers
  end

  def coverage
    unless @coverage
      @coverage = DB[:estimated_coverage].all.each_with_object({}){ |c, coverage| coverage[c[:pkg_attr]] = c[:coverage] }
    end
    @coverage
  end

  def coverage_stats
    unless @coverage_stats
      @coverage_stats = coverage.values.each_with_object(Hash.new(0)){ |c, cstat| cstat[c] += 1 }
    end
    @coverage_stats
  end

  def maintainer_stats
    unless @maintainer_stats
      @maintainer_stats = DistroPackage::Nix.packages.
        each_with_object(Hash.new(0)){ |pkg, mstat| mstat[pkg.maintainers.count] += 1 }
    end
    @maintainer_stats
  end

  def outdated
    unless @outdated
      @outdated = Hash.new{|h,k| h[k] = Hash.new{|h,k| h[k] = Array.new } }
      PackageUpdater::Updaters.each do |updater|
        DB[updater.friendly_name].all.each do |row|
          outdated[row[:pkg_attr]][row[:version_major]] << updater.friendly_name.to_s if row[:version_major]
          outdated[row[:pkg_attr]][row[:version_minor]] << updater.friendly_name.to_s if row[:version_minor]
          outdated[row[:pkg_attr]][row[:version_fix]] << updater.friendly_name.to_s if row[:version_fix]
        end
      end
    end
    @outdated
  end
  
  def is_major_update?(pkg, new_ver)
    v_t = PackageUpdater::Updater.tokenize_version(pkg.version)
    nv_t = PackageUpdater::Updater.tokenize_version(new_ver)
    return (
      not(v_t) or not(nv_t) or (v_t[0] != nv_t[0]) or
      (v_t[2]>=0 and (v_t[1] != nv_t[1]))
    )
  end

  def vulnerable
    unless @vulnerable
      @vulnerable = Hash.new{|h,k| h[k] = Hash.new}
      DB[:cve_match].all.each do |match|
        cve_product = "#{match[:product]}:#{match[:version]}"
        products = @vulnerable[match[:pkg_attr]]
        products[cve_product] = Set.new unless products[cve_product]
        products[cve_product] << match[:CVE]
      end
    end
    return @vulnerable
  end

  def refresh
    @vulnerable = nil
    @outdated = nil
    @maintainer_stats = nil
    @coverage_stats = nil
    @coverage = nil
    @maintainers = nil
    DistroPackage::Nix.refresh

    vulnerable
    outdated
    maintainer_stats
    coverage_stats
    coverage
    maintainers
  end

  def filter_packages(filter)
    Set.new( DistroPackage::Nix.by_internal_name.keys.select { |pkg|
      nixpkg = DistroPackage::Nix.by_internal_name[pkg]

      nixpkg and
      # maintainer count
      (not filter[:mc] or filter[:mc] == "" or filter[:mc].to_i == nixpkg.maintainers.count) and
      # coverage
      (not filter[:c] or filter[:c] == "" or filter[:c].to_i == coverage[pkg]) and
      #outdated
      (not filter[:outdated] or outdated.has_key?(pkg)) and
      # outdated which has a minor update
      (not filter[:outdated_minor] or (outdated.has_key?(pkg) and outdated[pkg].keys.find{|v| not is_major_update?(nixpkg, v)}) ) and
      # outdated which has a major update
      (not filter[:outdated_major] or (outdated.has_key?(pkg) and outdated[pkg].keys.find{|v| is_major_update?(nixpkg, v)}) ) and
      #vulnerable
      (not filter[:vulnerable] or vulnerable.has_key?(pkg)) and
      # has maintainer
      (not filter[:m] or filter[:m] == "" or (nixpkg.maintainers.index{ |m| m.downcase.include? filter[:m].downcase }))
      # to be continued
    })
  end

  def render_checked(value)
    (value ? "checked" : "")
  end

  def render_selected(value)
    (value ? "selected" : "")
  end

  def render_filter(params)
    %{
      <form method=get>
        <div class=filteritem>
          Maintainers: <select name=mc>
            <option></option>#{
              maintainer_stats.keys.
                  map{ |k| "<option #{ render_selected(params[:mc] == k.to_s) }>#{k}</option>" }.
                  join
            }
          </select><br>
          Coverage: <select name=c>
            <option></option>#{
              coverage_stats.keys.
                  map{|k| "<option #{ render_selected(params[:c] == k.to_s) }>#{k}</option>"}.
                  join
            }
          </select>
        </div>
        <div class=filteritem style="text-align: left">
          <input type=checkbox name=vulnerable #{ render_checked(params[:vulnerable]) }>Vulnerable<br>
          <input type=checkbox name=outdated #{ render_checked(params[:outdated]) }>Outdated
          <input type=checkbox name=outdated_minor #{ render_checked(params[:outdated_minor]) }>Minor
          <input type=checkbox name=outdated_major #{ render_checked(params[:outdated_major]) }>Major
        </div>
        <div class=filteritem>
          Maintainer: <input type=text name=m value="#{params[:m]}"><br>
          <input type=submit value="Apply Filter">
        </div>
      </form>
    }
  end
end


get '/' do
  coverage_report = coverage_stats.
      sort_by{ |cnum, ccnt| cnum }.
      map{ |c, cs| "<tr><td>#{c}</td><td><a href=/coverage?c=#{c}>#{cs}</a></td></tr>" }.
      join

  maintainer_report = maintainer_stats.
      sort_by{ |mnum, pcnt| mnum }.
      map{ |mc, ms| "<tr><td>#{mc}</td><td><a href=/coverage?mc=#{mc}>#{ms}</a></td></tr>" }.
      join

  needsattention_report = %{
      <tr><td>Potentially vulnerable</td><td><a href=/vulnerable>#{vulnerable.count}</a></td></tr>
      <tr><td>Unmaintained not covered</td><td><a href=/coverage?mc=0&c=0>#{
        filter_packages({:c => 0, :mc => 0}).count
      }</a></td></tr>
      <tr><td>Outdated unmaintained</td><td><a href=/outdated?mc=0>#{
        filter_packages({:mc =>0, :outdated => true}).count
      }</a></td></tr>
      <tr><td>Outdated</td><td><a href=/outdated>#{outdated.count}</a></td></tr>
  }

  permaintainer_report = maintainers.
      map{ |maintainer| %{
          <tr>
          <td>#{maintainer}</td>
          <td>#{filter_packages({ :m => maintainer }).count}</td>
          <td><a href=/outdated?m=#{CGI::escape(maintainer)}>#{filter_packages({ :m => maintainer, :outdated => true }).count}</a></td>
          <td><a href=/coverage?m=#{CGI::escape(maintainer)}&c=0>#{filter_packages({ :m => maintainer, :c => 0 }).count}</a></td>
          <td><a href=/vulnerable?m=#{CGI::escape(maintainer)}>#{filter_packages({ :m => maintainer, :vulnerable => true }).count}</a></td>
          </tr>
      } }.
      join

  haml :dashboard, :locals => {
    :coverage_report => coverage_report,
    :maintainer_report => maintainer_report,
    :needsattention_report => needsattention_report,
    :permaintainer_report => permaintainer_report
  }
end


get '/coverage' do
  filtered = filter_packages(params)
  report = coverage.
      select{ |pkg, c| filtered.include? pkg }.
      sort_by{ |pkg, c| c }.
      map{ |pkg, c| %{
        <tr><td>#{pkg}</td><td>#{c}</td>
        <td>#{DistroPackage::Nix.by_internal_name[pkg].maintainers.count}</td></tr>
      } }.
      join

  haml :coverage, :locals => { :coverage_report => report, :filter => render_filter(params) }
end


get '/outdated' do
  filtered = filter_packages(params)
  report = outdated.
      select{ |pkg, v| filtered.include? pkg }.
      sort_by{ |pkg, v| pkg }.
      map do |pkg, v|
        nixpkg = DistroPackage::Nix.by_internal_name[pkg]
        %{
            <tr><td>#{pkg}</td><td>#{nixpkg.version}</td>
            <td>#{v.
                select { |version, updaters| not is_major_update?(nixpkg, version) }.
                map { |version, updaters| "<span title=\"#{updaters.join(', ')}\">#{version}#{
                      patch_record = DB[:patches][:pkg_attr => pkg, :version => version]
                      patch_record ? "(<a href=/patch?p=#{pkg}&v=#{version}>p</a>)" : ""
                    }</span>" }.
                join(', ')
            }</td><td>#{v.
                select { |version, updaters| is_major_update?(nixpkg, version) }.
                map { |version, updaters| "<span title=\"#{updaters.join(', ')}\">#{version}#{
                      patch_record = DB[:patches][:pkg_attr => pkg, :version => version]
                      patch_record ? "(<a href=/patch?p=#{pkg}&v=#{version}>p</a>)" : ""
                    }</span>" }.
                join(', ')
            }</td>
        }
      end.
      join

    haml :outdated, :locals => { :outdated_report => report, :filter => render_filter(params.merge({:outdated => true})) }
end


get '/patch' do
  patch_record = DB[:patches][:pkg_attr => params[:p], :version => params[:v]]
  halt(404, 'no matching patch found') unless patch_record
  content_type 'text/plain', :charset => 'utf-8'
  %{
From: Nixpkgs Monitor <none@none>
Subject: #{params[:p]}: update from #{DistroPackage::Nix.by_internal_name[params[:p]].version} to #{params[:v]}#{
  vulnerable.has_key?(params[:p]) ? ", potentially fixes #{vulnerable[params[:p]].values.map{|s| s.to_a}.flatten.join(', ')}": ""
}

#{patch_record[:patch]}
  }
end

get '/vulnerable' do
  filtered = filter_packages(params)
  report = vulnerable.
      select{ |pkg, v| filtered.include? pkg }.
      sort_by{ |pkg, v| pkg }.
      map do |pkg, candidates|
        candidates.map{ |prod, cves| %{
            <tr><td>#{pkg}:#{DistroPackage::Nix.by_internal_name[pkg].version}</td>
            <td>#{prod}</td><td>#{cves.to_a.join(', ') }</td></tr>
        } }.
        join
      end.
      join

  haml :vulnerable, :locals => { :vulnerable_report => report, :filter => render_filter(params.merge({:vulnerable => true})) }
end


get '/refresh' do
  refresh
  "Refresh Done"
end


get '/default.css' do
<<STYLE
body {
    background-color: #707070;
    margin: 0 10% 0 10%;
    font-family: "Nimbus Sans L", sans-serif;
}
div.header { overflow:hidden }
div.header div.name { font-weight: bold; float:left }
div.header div.links { float: right }
div.dashitem, div.header {
    margin: 0.5em;
    background-color: white;

    /* Put a rounded border around the page. */
    border: 1px solid black;
    padding: 1em;
    border-radius: 1em;
    border-radius: 1em;
    box-shadow: #404040 0px 5px 50px;
}
div.dashitem { float: left; }
div.dashitem th {
    border-bottom: dotted 1px;
}
div.filteritem { float: left; text-align: right; padding: 0 1em }
a { text-decoration: none; }
a:hover { text-decoration: underline; }
a:link { color: #0048b3; }
a:visited { color: #002a6a; }
a.no-hover:hover { background: none; }
STYLE
end

__END__

@@dashboard

<link rel="stylesheet" href="/default.css" type="text/css" />

.header
  .name NixPkgs Monitor
  .links
    %a(href="http://github.com/phreedom/nixpkgs-monitor") source

.dashitem#coverage
  %span.header Coverage
  %table
    %tr
      %th Coverage
      %th Packages
    = coverage_report

.dashitem#maintainers
  %span.header Maintainers
  %table
    %tr
      %th Maintainers
      %th Packages
    = maintainer_report

.dashitem#needsattention
  %table
    = needsattention_report

.dashitem#permaintainer
  %span.header Per Maintainer
  %table
    %tr
      %th Maintainer
      %th Packages
      %th Outdated
      %th Not covered
      %th Vulnerable
    = permaintainer_report


@@coverage

<link rel="stylesheet" href="/default.css" type="text/css" />

.dashitem
  = filter

.dashitem
  %table
    %tr
      %th Attr Path
      %th Estimated Coverage
      %th Maintainers
    = coverage_report


@@outdated

<link rel="stylesheet" href="/default.css" type="text/css" />

.dashitem
  = filter

.dashitem
  %table
    %tr
      %th Attr Path
      %th Current
      %th Minor Update(s)
      %th Major Update(s)
    = outdated_report


@@vulnerable

<link rel="stylesheet" href="/default.css" type="text/css" />

.dashitem
  = filter

.dashitem
  %table
    %tr
      %th Attr Path/Version
      %th CVE Product
      %th CVE ID(s)
    = vulnerable_report
